// ls || cat | (cat) && clear | (cat & pwd) case to check in tree
// Master@Mindv3.0> echo foo | grep "found" > log && ls < input || echo "found" > success [ Case Solved ]

/* Parsing Reminder

	heredoc delimiter if a next delimiter to be joined has quotes
	its not going to be saved, since we save for only the first one
	put in mind to fix later inchallah (CHECKED)

	need to check for $ if its wrapped around quotes it will be the only
	token that we should not remove quotes from, KEEP IN MIND (CHECKED)

	keep in mind to add the red pointer into the tree nodes. (CHECKED)

	> Heredoc file descriptor transporation (Checked)
	
	> Pre parsing for this case (ls << eof) (Checked)

	> Delimiter trimming with no WhiteSpaces (Checked)

	> Add the Command itself to the first arg in arg struct (Checked)

	> Check the red_system need to protect Malloc Failure (Checked)

	> Need to add the Arg Struct and Red struct into the cleaning (Checked)

	> if the PWD AND OLDPWD are unetted nothing of them is updated, yet if exported they need to be changed (TO CHECK AFTER EXPORT IS WORKING)

	> Update the OLDPWD Also (TODO in Cd) (CHECKED)

	> Ft_strdup Failure in building the tree recursively (TODO) NEED TO CHECK CAREFULLY HOW IT SHOULD BE PROTECTED

	> re_built instead of tree in case of no command or operator (CHECKED)

	Change in Plan, the plan in which i leave quotes for expanding, i wont leave them, it interrupt
	the normal flow of removing quotes [ Case awk '{print $1}'], the quotes should be removed before
	given to execve in the Execution

*/

/*
	Execution Reminder 
	Master@Mindv3.0> ./minishell
	Migrane: command not found: ./minishell
	Need to handle ./Executable

	Case --> if multiple heredoc found redirected inisde of a command, close the firsts ones, 
	and only execute the command on the last heredoc
	Case --> [ls < l | cat] if the redirection failed nothing will be piped

	if CTRL + C, need to update the exit status into 1 (TODO)

	Master@Mindv3.0> "''"
	Migrane: command not found: ' 

	Master@Mindv3.0> ls > input < out
└─ COMMAND [ls]
      └─  [Red]  > input --> ID-> OUTPUT_FILE_ID
      └─  [Red]  > out --> ID-> INPUT_FILE_ID
      └─  [Arg]  > ls --> Quoted > 0
      └─ Space Next True
Migrane: out : No such file or directory
CTRL C NOT WORKING (HANGED)
*/



					--------------------------->> NORMINETTE <<---------------------------

* if an error in joining occurs, check ft_strdjoin while loop
* Ask Ouss if he uses the pointed variable in the env struct, cuz we deleted the zero point

void zero_point(t_data *data)
{
    t_envlist *trav;
    t_exportlist *trav_exp;

    trav = data->env;
    trav_exp = data->exp;
    while (trav != NULL)
    {
        trav->pointed = false;
        trav = trav->next;
    }
    while(trav_exp != NULL)
    {
        trav_exp->pointed = false;
        trav_exp = trav_exp->next;
    }
}
* Check tools4.c, and ask Ouss if he uses any of the functions that exsits there
* if execution of operatos failed in some case, check set_end function

*i need to free the tree if recursive build has failed, i need to clean it
only from fds since we cleaned the yard containing the red and arg system structs
* if heredoc bugged, go to here_doc_check ( // ?? set it on the same first node??)
	while (curr != NULL)
	{
		if (requirements(curr, id_class, data))
		{
			curr->here_times = 0; here and set id_class
			if (!change_id(curr->next, data)
				|| !open_heredoc(id_class, curr, data))
				return (0);
		}
		curr = curr->next;
	}

During the Big Scan, check for any function that add a node into a list 
then check after strdup Failure, u need to free the allocated node
before returning the NULL.

in case of arg system failing suddenly check the uncommented part in arg_system function

static int	operations(t_token *id_class)
{
	t_arg	*class;
	t_arg	*new;
	t_token	*arg;

	if (id_class->cmd_added == false)
	{
		class = new_argument(id_class);
		if (!class)
			return (free(new), free(new->value), 0);
		printf("class2 > %s\n", class->value);
		add_arg_to_list(&id_class->arg, class);
		id_class->cmd_added = true;
	}
	arg = get_argument(id_class);
	if (!arg)
	{
		// class = new_argument(id_class);
		// if (!class)
		// 	return (0);
		// printf("class1 > %s\n", class->value);
		// add_arg_to_list(&id_class->arg, class);
		return (1);
	}
	new = new_argument(arg);
	printf("new > %s\n", new->value);
	if (!new)
		return (0);
	return (add_arg_to_list(&id_class->arg, new), 1);
}


CASE 

ls -la || cat '-e' | pwd && cat -e| > f1 > f2 << ok << eof
MAKE SURE THAT ALL NAMES IN MINISHELL ARE LOWERCASE (CHECKED)

ADD -Wall -Wextra -Werror Flags

HEREDOC CTRL + C dammage the normal state of CTRL + C signal in the main

Master@Mindv3.0> << f4|
MasterMind: Syntax Error Near Unexpected Token `|' (CHECKED)
Add exit to be written when CTRL + D is made in the main (CHECKED)


to Ouss

Master@Mindv3.0> [wd
└─ COMMAND [[wd]
      └─  [Arg]  > [wd --> Quoted > 0
==389800== Syscall param execve(filename) points to unaddressable byte(s)
==389800==    at 0x4A1908B: execve (syscall-template.S:120)
==389800==    by 0x40AA0A: exec_node (in /home/ayel-bou/Desktop/MasterGit/MasterMerged/MasterMerged/parsing/minishell)
==389800==    by 0x40AC5F: recursive_execution (in /home/ayel-bou/Desktop/MasterGit/MasterMerged/MasterMerged/parsing/minishell)
==389800==    by 0x40AE4A: execute_tree (in /home/ayel-bou/Desktop/MasterGit/MasterMerged/MasterMerged/parsing/minishell)
==389800==    by 0x401576: main (in /home/ayel-bou/Desktop/MasterGit/MasterMerged/MasterMerged/parsing/minishell)
==389800==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==389800== 
Migrane: [wd: command not found


Master@Mindv3.0> cd ..
└─ COMMAND [cd]
      └─  [Arg]  > cd --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > .. --> Quoted > 0
Master@Mind: Permission Denied
Master@Mindv3.0> echo $?
└─ COMMAND [echo]
      └─  [Arg]  > echo --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > $? --> Quoted > 0
-1
Master@Mindv3.0> cd ..
└─ COMMAND [cd]
      └─  [Arg]  > cd --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > .. --> Quoted > 0
Master@Mindv3.0> echo $?
└─ COMMAND [echo]
      └─  [Arg]  > echo --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > $? --> Quoted > 0
-1

WATCH OUT FROM EXIT STATUS IT SHOULD BE ZERO

Master@Mind: export: `3_12312': not a valid identifier
Master@Mindv3.0> echo $?
└─ COMMAND [echo]
      └─  [Arg]  > echo --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > $? --> Quoted > 0
0

OUSS -----------------------
case in exporing using expand (if the var isnt created, using append it must be created even if its not )
export c+=$b (c does not exists, but must be created)

 asdasMaster@Mindv3.0> echo -  - - - -- - asdas
└─ COMMAND [echo]
      └─  [Arg]  > echo --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > - --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > - --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > - --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > - --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > -- --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > - --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > asdas --> Quoted > 0
 - - - -- - asdasMaster@Mindv3.0>

 Master@Mindv3.0> echo -n -n  -n  asdas
└─ COMMAND [echo]
      └─  [Arg]  > echo --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > -n --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > -n --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > -n --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > asdas --> Quoted > 0
 -n -n asdasMaster@Mindv3.0> echo -n -n  -n -nnnnnn  asdas
└─ COMMAND [echo]
      └─  [Arg]  > echo --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > -n --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > -n --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > -n --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > -nnnnnn --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > asdas --> Quoted > 0
 -n -n -nnnnnn asdasMaster@Mindv3.0> 

 Master@Mindv3.0> export a="    a"
└─ COMMAND [export]
      └─  [Arg]  > export --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > a= --> Quoted > 0
      └─  [Arg]  >      a --> Quoted > 0
Master@Mind: export: `a=        a': not a valid identifier

bash-3.2$ echo $a
asdasd asdasdd
bash-3.2$ ls
Makefile                identificators          minishell               minishell.h             signal_handlers         tools
debbugers               mastermind              minishell.c             re_identificators       syntax
bash-3.2$ ./minishell 
Master@Mindv3.0> echo $a
└─ COMMAND [echo]
      └─  [Arg]  > echo --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > $a --> Quoted > 0
        asdasd  asdasdd (tabs should be changed into spaces, only seconds)

➜  parsing git:(master) ✗ env -i ./minishell 
Master@Mindv3.0> ls
└─ COMMAND [ls]
      └─  [Arg]  > ls --> Quoted > 0
Failed To Merge ENV: Undefined error: 0
Merge Failed: Undefined error: 0

Master@Mindv3.0> unset PATH
└─ COMMAND [unset]
      └─  [Arg]  > unset --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > PATH --> Quoted > 0
Master@Mindv3.0> ls
└─ COMMAND [ls]
      └─  [Arg]  > ls --> Quoted > 0
Execute         MightHelp       MustBeDone.txt  README.md       attachment      file
          lib             parsing

bash-3.2$ export a=2323123 && echo $a && (cd .. && pwd) && pwd
2323123
/mnt/homes/ayel-bou/Desktop/MasterGit/MasterMerged/MasterMerged
/mnt/homes/ayel-bou/Desktop/MasterGit/MasterMerged/MasterMerged/parsing (exit status of cd)

Master@Mindv3.0> ls > a > b > c 
└─ COMMAND [ls]
      └─  [Red]  > a --> ID-> OUTPUT_FILE_ID
      └─  [Red]  > b --> ID-> OUTPUT_FILE_ID
      └─  [Red]  > c --> ID-> OUTPUT_FILE_ID
      └─  [Arg]  > ls --> Quoted > 0
      └─ Space Next True
a
Master@Mindv3.0> cat c
└─ COMMAND [cat]
      └─  [Arg]  > cat --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > c --> Quoted > 0
Makefile
a
b
c
debbugers
identificators
mastermind
minishell
minishell.c
minishell.h
re_identificators
signal_handlers
syntax
tools
Master@Mindv3.0> cat a 
└─ COMMAND [cat]
      └─  [Arg]  > cat --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > a --> Quoted > 0
      └─ Space Next True
b
Master@Mindv3.0> cat b
└─ COMMAND [cat]
      └─  [Arg]  > cat --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > b --> Quoted > 0
c


Master@Mindv3.0> ./a
└─ COMMAND [./a]
      └─  [Arg]  > ./a --> Quoted > 0
Migrane: ./a: command not found
You have access to multiple processes named minishell:
    a) 44099 ./minishell
    b) 44247 ./minishell
Which process? (letter or PID) b

Process:         minishell [44247]
Path:            /Volumes/VOLUME/*/minishell
Load Address:    0x107647000
Identifier:      minishell
Version:         ???
Code Type:       X86-64
Parent Process:  minishell [44099]

Date/Time:       2025-08-11 10:36:01.997 +0100
Launch Time:     2025-08-11 10:36:00.777 +0100
OS Version:      Mac OS X 10.15.7 (19H2026)
Report Version:  7
Analysis Tool:   /Applications/Xcode.app/Contents/Developer/usr/bin/leaks
Analysis Tool Version:  Xcode 12.4 (12D4e)

Physical footprint:         304K
Physical footprint (peak):  304K
----

leaks Report Version: 4.0
Process 44247: 420 nodes malloced for 338 KB
Process 44247: 3 leaks for 48 total leaked bytes.

    3 (48 bytes) << TOTAL >>

      2 (32 bytes) ROOT LEAK: 0x7fcc83704240 [16]
         1 (16 bytes) 0x7fcc83705c60 [16]  length: 1  "a"

      1 (16 bytes) ROOT LEAK: 0x7fcc83705060 [16]  length: 1  "a"

Master@Mindv3.0> echo "salam" > .
└─ COMMAND [echo]
      └─  [Red]  > . --> ID-> OUTPUT_FILE_ID
      └─  [Arg]  > echo --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > salam --> Quoted > 0
      └─ Space Next True
.
Master@Mind: . : Is a directory
Master@Mindv3.0> echo $?
└─ COMMAND [echo]
      └─  [Arg]  > echo --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > $? --> Quoted > 0
0

Master@Mindv3.0> login
└─ COMMAND [login]
      └─  [Arg]  > login --> Quoted > 0
login: ^C
Master@Mindv3.0> 
login: 
---------------------------------------------------------------------------
mine
Master@Mindv3.0> cd adsasdas
└─ COMMAND [cd]
      └─  [Arg]  > cd --> Quoted > 0
      └─ Space Next True
      └─  [Arg]  > adsasdas --> Quoted > 0

      bash-3.2$ exit 23 3 3 3
exit
bash: exit: too many arguments
bash-3.2$ exit asdas 23 3 3 3
exit
bash: exit: asdas: numeric argument required
➜  parsing git:(master) ✗ 

bash-3.2$ exit 232312312312312312312312
exit
bash: exit: 232312312312312312312312: numeric argument required

Master@Mindv3.0> (sd && ((pwd && ls )) || "") &&()
MasterMind: Syntax Error Near Unexpected Token `)'
Master@Mindv3.0> (sd && ((
--------------------------------

Master@Mindv3.0> cat
└─ COMMAND [cat]
      └─  [Arg]  > cat --> Quoted > 0
^\

^C
Master@Mindv3.0> Master@Mindv3.0> 
CTRL + \, should not do anuything in the parent, yet in the child let be as it is

ASk ouss if debugged or printed
Master@Mindv3.0> > "$a $a $a"
└─ COMMAND [F4K3]
      └─  [Red]  > $a $a $a --> ID-> OUTPUT_FILE_ID
      └─  [Arg]  > F4K3 --



TEST IT AT THE END 

	Master@Mindv3.0> ls > input < out
└─ COMMAND [ls]
      └─  [Red]  > input --> ID-> OUTPUT_FILE_ID
      └─  [Red]  > out --> ID-> INPUT_FILE_ID
      └─  [Arg]  > ls --> Quoted > 0
      └─ Space Next True
Migrane: out : No such file or directory
CTRL C NOT WORKING (HANGED)
*/